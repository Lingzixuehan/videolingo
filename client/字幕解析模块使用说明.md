# 字幕解析模块使用说明

## 项目结构

```
backend/
├── src/
│   ├── __init__.py              # 模块初始化
│   └── subtitle_parser.py       # 字幕解析核心代码
├── tests/
│   └── test_subtitle_parser.py  # 单元测试
├── examples/
│   ├── example.srt              # SRT 示例文件
│   ├── example.ass              # ASS 示例文件
│   ├── demo.py                  # 演示脚本
│   └── example.json             # 生成的 JSON 示例
├── requirements.txt             # Python 依赖
├── README.md                    # 英文文档
└── 使用说明.md                  # 中文使用说明（本文件）
```

## 安装

1. 确保安装了 Python 3.7+
2. 安装依赖：

```bash
cd backend
pip install -r requirements.txt
```

## 快速开始

### 1. 基本使用

```python
from src.subtitle_parser import SubtitleParser

# 创建解析器
parser = SubtitleParser()

# 解析字幕文件
result = parser.parse_subtitle_file("example.srt")

# 访问结果
print(f"总句数: {result['total_sentences']}")
print(f"总时长: {result['duration']} 秒")

# 遍历所有句子
for sentence in result['sentences']:
    print(f"[{sentence['index']}] {sentence['start']}s - {sentence['end']}s")
    print(f"    {sentence['text']}")
```

### 2. 保存为 JSON

```python
# 解析并保存
output_file = parser.parse_and_save_json("input.srt", "output.json")
print(f"已保存到: {output_file}")

# 或自动生成文件名
output_file = parser.parse_and_save_json("input.srt")  # 生成 input.json
```

### 3. 时间查询

```python
# 查找特定时间的句子
result = parser.parse_subtitle_file("example.srt")
sentence = parser.get_sentence_at_time(result['sentences'], 5.0)

if sentence:
    print(f"5秒处的句子: {sentence['text']}")
```

## 运行示例

### 运行演示脚本

```bash
cd backend
python examples/demo.py
```

### 运行测试

```bash
cd backend
python tests/test_subtitle_parser.py
```

所有测试应该通过：
```
测试结果: 6/6 通过
所有测试通过！✓
```

## 输出格式

解析后的 JSON 格式如下：

```json
{
  "sentences": [
    {
      "index": 0,
      "start": 1.5,
      "end": 4.2,
      "text": "这是第一句话。",
      "video_timestamp": "00:00:01,500 --> 00:00:04,200"
    }
  ],
  "total_sentences": 1,
  "duration": 4.2,
  "source_file": "example.srt",
  "format": "srt"
}
```

### 字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| `sentences` | Array | 句子数组 |
| `index` | Integer | 句子索引（从0开始） |
| `start` | Float | 开始时间（秒） |
| `end` | Float | 结束时间（秒） |
| `text` | String | 句子文本（已清理格式标记） |
| `video_timestamp` | String | 原始时间戳格式 |
| `total_sentences` | Integer | 总句数 |
| `duration` | Float | 总时长（秒） |
| `source_file` | String | 源文件名 |
| `format` | String | 字幕格式（srt/ass/ssa等） |

## 支持的字幕格式

- `.srt` - SubRip 字幕
- `.ass` - Advanced SubStation Alpha
- `.ssa` - SubStation Alpha
- `.sub` - MicroDVD 字幕
- `.vtt` - WebVTT 字幕

## 功能特性

1. **多格式支持**：支持常见的字幕格式（srt, ass, ssa, sub, vtt）
2. **格式清理**：自动移除 ASS/SSA 样式标记（如 `{\b1}`, `{\i1}` 等）
3. **时间转换**：毫秒自动转换为秒（保留3位小数）
4. **时间戳格式化**：保留原始格式的时间戳字符串
5. **时间查询**：根据时间点快速查找对应句子
6. **JSON 导出**：将解析结果保存为结构化 JSON
7. **错误处理**：友好的错误提示（文件不存在、格式不支持等）

## API 参考

### SubtitleParser 类

#### `parse_subtitle_file(file_path: str) -> Dict[str, Any]`
解析字幕文件并返回句级数据

**参数：**
- `file_path`: 字幕文件路径

**返回：**
- 包含 sentences、total_sentences、duration 等字段的字典

**异常：**
- `FileNotFoundError`: 文件不存在
- `ValueError`: 不支持的文件格式

#### `parse_and_save_json(input_file: str, output_file: str = None) -> str`
解析字幕并保存为 JSON

**参数：**
- `input_file`: 输入字幕文件路径
- `output_file`: 输出 JSON 路径（可选，默认为输入文件名.json）

**返回：**
- 输出文件路径

#### `get_sentence_at_time(sentences: List[Dict], time_seconds: float) -> Optional[Dict]`
获取指定时间点的句子

**参数：**
- `sentences`: 句子列表
- `time_seconds`: 时间点（秒）

**返回：**
- 匹配的句子字典，未找到返回 None

## 技术实现

### 依赖库
- **pysubs2**: 专业的字幕解析库，支持多种格式

### 核心流程
1. 使用 `pysubs2.load()` 加载字幕文件
2. 遍历所有字幕事件（跳过注释和空行）
3. 提取时间信息（start/end）并转换为秒
4. 清理文本内容（移除样式标记）
5. 格式化时间戳字符串
6. 组装成统一的 JSON 结构

### 时间处理
- 输入：pysubs2 提供的毫秒时间戳
- 转换：毫秒 ÷ 1000 = 秒（保留3位小数）
- 格式化：根据原始格式重新生成时间戳字符串

### 文本清理
使用正则表达式移除 ASS/SSA 格式的样式标记：
```python
text = re.sub(r'\{[^}]*\}', '', text)
```

## 常见问题

### Q: 为什么控制台显示中文乱码？
A: 这是 Windows 控制台编码问题，不影响功能。JSON 文件中的中文是正确的。已在测试代码中添加 UTF-8 输出设置。

### Q: 支持哪些字幕格式？
A: 支持 .srt, .ass, .ssa, .sub, .vtt 等常见格式。

### Q: 如何处理多行字幕？
A: 多行字幕会被合并为一句，中间用空格连接。

### Q: 时间精度如何？
A: 时间精度保留到毫秒（小数点后3位）。

## 下一步开发建议

1. **句子合并**：实现智能合并短句的功能
2. **断句优化**：支持按标点符号重新断句
3. **多语言检测**：自动识别字幕语言
4. **批量处理**：支持批量处理多个字幕文件
5. **Web API**：提供 REST API 接口
6. **前端集成**：与 front 目录的前端项目集成

## 许可证

MIT License
